// ====================================================
//      VULNERABILITY REPORT SERVICE
// ====================================================

const VulnerabilityReport = require('../models').VulnerabilityReport;
const models = require('../models');
const { Op } = require("sequelize");
const db = require('../models/index');
const { uploadFile, deleteFile } = require('./upload');
const { successMsg, errorMsg, exceptionMsg, unauthhorized } = require('../utils/responses');
const { saveLog } = require('./log');
const { sendReportToAdminMails, sendMail } = require('./email');
const { notificationType, message, saveAdminNotifications, saveBusinessNotification, saveUserNotification } = require('./notification');

//==============================================
//Mostrar todos los reportes de vulnerabilidad
//==============================================
async function getVulnerabilityReports(req, res) {
    try {
        let where = {};
        if (req.query.title && req.query.title != null && req.query.title != undefined) {
            where = {
                title: {
                    [Op.like]: `%${req.query.title}%`
                }
            }
        }

        const vulnerabilityReports = await VulnerabilityReport.findAll({
            where,
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        });
        successMsg(res, 200, 'correcto', vulnerabilityReports)
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error);
    }
}

//========================================================
//Mostrar todos los reportes de vulnerabilidad por estatus
//========================================================
async function getVulnerabilityReportsByStatus(req, res) {
    try {
        const status = req.params.status;
        const vulnerabilityReports = await VulnerabilityReport.findAll({
            where: { status },
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        });
        successMsg(res, 200, 'correcto', vulnerabilityReports);
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error);
    }
}

//=========================================
//Mostrar reporte de vulnerabilidad por id
//=========================================
async function getVulnerabilityReportById(req, res) {
    try {
        const id = req.params.id;
        const vulnerabilityReport = await VulnerabilityReport.findOne({
            where: { id },
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step
            ],
            order: [
                [models.Step, 'stepNumber', 'asc']
            ]
        })

        if (!vulnerabilityReport)
            return exceptionMsg(res, id, 'Reporte de Vulnerabilidad');

        if (req.user.roleId === 2 && req.user.id !== vulnerabilityReport.Hacker.userId)
            return unauthhorized(res);

        if (req.user.businessId != undefined && req.user.businessId != null && req.user.businessId !== vulnerabilityReport.Program.businessId)
            return unauthhorized(res);

        successMsg(res, 200, 'correcto', vulnerabilityReport);
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error)
    }
}

//===============================================
//Mostrar reporte de vulnerabilidad por approved
//==============================================
async function getVulnerabilityReportsByApproved(req, res) {
    try {
        const approved = req.params.approved;
        let where = { approved };

        if (req.user.roleId == 2) {
            const hacker = await models.Hacker.findOne({ where: { userId: req.user.id } });
            where = { approved, hackerId: hacker.id };
        }

        const vulnerabilityReports = await VulnerabilityReport.findAll({
            where,
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        });
        successMsg(res, 200, 'correcto', vulnerabilityReports)
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error);
    }
}

//==================================================
//Mostrar reportes de vulnerabilidad por program Id
//==================================================
async function getVulnerabilityReportsByProgramId(req, res) {
    try {
        const programId = req.params.programId;
        let approvedView = [0, 1, 2]

        let checkProgram = await models.Program.findOne({
            where: { id: programId }
        });
        if (!checkProgram)
            return res.status(404).send({
                ok: false,
                message: `No existe el programa con id: ${programId}`,
            });

        if (req.user.businessId != undefined && checkProgram.businessId != req.user.businessId)
            return res.status(400).send({
                ok: false,
                message: `Datos de búsqueda de programa ${programId} incorrectos`
            });

        if (req.user.businessId != undefined)
            approvedView = [1]

        const vulnerabilityReports = await VulnerabilityReport.findAll({
            where: { programId, approved: approvedView },
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        })
        successMsg(res, 200, 'correcto', vulnerabilityReports)
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error)
    }
}

//==================================================
//Mostrar reportes de vulnerabilidad por hacker Id
//==================================================
async function getVulnerabilityReportsByHackerId(req, res) {
    try {
        const hackerId = req.params.hackerId;

        let checkHacker = await models.Hacker.findOne({
            where: { id: hackerId }
        });
        if (!checkHacker)
            return res.status(404).send({
                ok: false,
                message: `No existe el hacker con id: ${hackerId}`,
            });

        if (req.user.roleId == 2) {
            const user = await models.User.findOne({ where: { id: checkHacker.userId } });
            if (user.id != req.user.id)
                return res.status(400).send({
                    ok: false,
                    message: `Datos de búsqueda de hacker ${hackerId} incorrectos`
                });
        }

        let where = { '$hackerId$': hackerId };
        if (req.query.title && req.query.title != null && req.query.title != undefined) {
            where = {
                hackerId,
                title: {
                    [Op.like]: `%${req.query.title}%`
                }
            }
        }

        const vulnerabilityReports = await VulnerabilityReport.findAll({
            where,
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        })
        successMsg(res, 200, 'correcto', vulnerabilityReports)
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error)
    }
}

//==================================================
//Mostrar reportes de vulnerabilidad por business Id
//==================================================
async function getVulnerabilityReportsByBusinessId(req, res) {
    try {
        const businessId = req.params.businessId;
        let approvedView = [0, 1, 2]

        let checkBusiness = await models.Business.findOne({
            where: { id: businessId }
        });
        if (!checkBusiness)
            return res.status(404).send({
                ok: false,
                message: `No existe la empresa con id: ${businessId}`,
            });

        if (req.user.businessId != undefined && req.user.businessId != null) {
            approvedView = [1]
            if (req.user.businessId != checkBusiness.id)
                return unauthhorized(res);
        }

        let where = { approved: approvedView };
        if (req.query.title && req.query.title != null && req.query.title != undefined) {
            where = {
                approved: approvedView,
                title: {
                    [Op.like]: `%${req.query.title}%`
                }
            }
        }

        const vulnerabilityReports = await VulnerabilityReport.findAll({
            where,
            include: [{
                    model: models.Program,
                    where: { businessId },
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        });
        successMsg(res, 200, 'correcto', vulnerabilityReports)
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error)
    }
}

//================================================================
//Mostrar reportes de vulnerabilidad por tipo de vulnerabilidad Id
//================================================================
async function getVulnerabilityReportsByVulnerabilityTypeId(req, res) {
    try {
        const vulnerabilityTypeId = req.params.vulnerabilityTypeId;

        let checkVulnerabilityType = await models.VulnerabilityType.findOne({
            where: { id: vulnerabilityTypeId }
        });
        if (!checkVulnerabilityType)
            return res.status(404).send({
                ok: false,
                message: `No existe el tipo de vulnerabilidad con id: ${vulnerabilityTypeId}`,
            });

        const vulnerabilityReports = await VulnerabilityReport.findAll({
            where: { vulnerabilityTypeId },
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        })
        successMsg(res, 200, 'correcto', vulnerabilityReports)
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error)
    }
}

//================================================================
//Reportes de vulnerabilidad de programas públicos
//================================================================
async function getVulnerabilityReportsByProgramPublics(req, res) {
    try {
        const vulnerabilityReports = await VulnerabilityReport.findAll({
            where: { approved: 1 },
            include: [{
                    model: models.Program,
                    where: { public: 1, approved: 1 },
                    include: [{
                            model: models.Asset,
                            required: false,
                            include: [models.AssetType]
                        },
                        {
                            model: models.Vulnerability,
                            required: false,
                            include: [models.VulnerabilityType]
                        },
                        {
                            model: models.VulnerabilityType,
                            required: false
                        },
                        {
                            model: models.File,
                            required: false
                        },
                        {
                            model: models.Business,
                            required: false
                        }
                    ]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step
            ],
            order: [
                [models.Step, 'stepNumber', 'asc']
            ]
        })
        successMsg(res, 200, 'correcto', vulnerabilityReports)
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error)
    }
}

//=================================
//Crear reporte de vulnerabilidad
//=================================
async function saveVulnerabilityReport(req, res) {
    let transaction = await db.sequelize.transaction();
    try {
        let body = req.body;

        let steps = JSON.parse(body.steps);
        if (steps.length === 0)
            return res.status(400).json({
                ok: false,
                err: {
                    message: "Debe ingresar los pasos para replicar la vulnerabilidad"
                }
            });

        if (!req.files) {
            return res.status(400).json({
                ok: false,
                err: {
                    message: "No hay archivo de evidencia seleccionado"
                }
            });
        }

        let checkProgram = await models.Program.findOne({
            where: { id: body.programId }
        });
        if (!checkProgram)
            return res.status(404).send({
                ok: false,
                message: `No existe el programa con id: ${body.programId}`,
            });

        if (req.user.Hacker.id !== Number(body.hackerId))
            return unauthhorized(res);

        if (checkProgram.public === 0) {
            const invitations = await models.HackerInvitation.findAll({
                where: { hackerId: req.user.Hacker.id, programId: checkProgram.id, status: 1, approved: 1 }
            });
            if (invitations.length === 0)
                return unauthhorized(res);
        }

        let checkHacker = await models.Hacker.findOne({
            where: { id: body.hackerId }
        });
        if (!checkHacker)
            return res.status(404).send({
                ok: false,
                message: `No existe el hacker con id: ${body.hackerId}`,
            });

        let checkAsset = await models.Asset.findOne({
            where: { id: body.assetId }
        });
        if (!checkAsset)
            return res.status(404).send({
                ok: false,
                message: `No existe el activo con id: ${body.assetId}`,
            });

        let checkVulnerabilityType = await models.VulnerabilityType.findOne({
            where: { id: body.vulnerabilityTypeId }
        });
        if (!checkVulnerabilityType)
            return res.status(404).send({
                ok: false,
                message: `No existe el tipo de vulnerabilidad con id: ${body.vulnerabilityTypeId}`,
            });

        let checkVulnerability = await models.Vulnerability.findOne({
            where: { id: body.vulnerabilityId }
        });
        if (!checkVulnerability)
            return res.status(404).send({
                ok: false,
                message: `No existe la vulnerabilidad con id: ${body.vulnerabilityId}`,
            });

        let newVulnerabilityReport = {
            title: body.title,
            description: body.description,
            impact: body.impact,
            programId: body.programId,
            hackerId: body.hackerId,
            vulnerabilityId: body.vulnerabilityId,
            vulnerabilityTypeId: body.vulnerabilityTypeId,
            assetId: body.assetId,
            approved: 0,
            status: body.status || 1
        }

        const vulnerabilityReport = await VulnerabilityReport.create(newVulnerabilityReport, { transaction });

        req.params.type = 'reports';
        req.params.format = 'file';
        req.params.id = vulnerabilityReport.id;
        const file = await uploadFile(req, res)

        vulnerabilityReport.set({ file });
        await vulnerabilityReport.save({ transaction });

        let fileName = "";

        function getFileByStep(stepNumber) {

            let file = null;

            let keys = Object.keys(req.files);
            let key;

            for (let i = 0; i < keys.length; i++) {
                key = keys[i]
                if (parseInt(key, 10) === stepNumber) {
                    file = req.files[key]
                    break;
                }
            }

            return file

        }
        for await (step of steps) {
            fileName = ""
            let newStep = {
                reportId: vulnerabilityReport.id,
                description: step.description,
                stepNumber: step.stepNumber,
                file: fileName,
                status: 1
            }
            let stepNew = await models.Step.create(newStep, { transaction })
            if (step.file && step.file != null) {
                req.params.type = 'steps';
                req.params.format = 'file';
                req.params.id = stepNew.id;
                req.files.file = getFileByStep(step.stepNumber);
                fileName = await uploadFile(req, res);
                stepNew.set({ file: fileName });
                await stepNew.save({ transaction });
            }
        }

        await saveAdminNotifications(res, message.report, vulnerabilityReport.title, notificationType.report, vulnerabilityReport.id);
        saveLog(req, "create", "VulnerabilityReport", vulnerabilityReport.id, req.user.id);
        await transaction.commit();

        const admins = await models.User.findAll({ where: { roleId: 1 } });
        var context = {
            hackerName: checkHacker.nickname,
            programName: checkProgram.name,
            reportTitle: vulnerabilityReport.title,
            logoVulnhunting: `${process.env.BACKEND_URL}file/logo/logo1.png`,
            logoEmail: `${process.env.BACKEND_URL}file/logo/email.png`,
            urlWeb: `${process.env.CLIENT_CORS_URL}`,
            app: `${process.env.APP_NAME}`
        }
        sendReportToAdminMails(admins, 'Nuevo reporte registrado', 'newReportAdmin', context);


        const msg = vulnerabilityReport.title ?
            `${vulnerabilityReport.title} creado con exito` :
            'creación exitosa!'

        const report = await VulnerabilityReport.findOne({
            where: { id: vulnerabilityReport.id },
            include: [models.Program,
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc']
            ]
        })

        successMsg(res, 200, msg, report);
    } catch (error) {
        await transaction.rollback();
        errorMsg(res, 500, 'Lo sentimos!, hemos  cometido un error', error)
    }
}

//======================================
//Actualizar reporte de vulnerabilidad
//======================================
async function updateVulnerabilityReportById(req, res) {
    try {
        const id = req.params.reportId;
        const body = req.body;
        const vulnerabilityReport = await VulnerabilityReport.findOne({ where: { id }, include: [models.Hacker] })

        if (!vulnerabilityReport)
            return exceptionMsg(res, id, 'reporte de Vulnerabilidad');

        if (req.user.Hacker.id !== vulnerabilityReport.Hacker.id)
            return unauthhorized(res);

        let checkAsset = await models.Asset.findOne({
            where: { id: body.assetId }
        });
        if (!checkAsset)
            return res.status(404).send({
                ok: false,
                message: `No existe el activo con id: ${body.assetId}`,
            });

        let checkVulnerabilityType = await models.VulnerabilityType.findOne({
            where: { id: body.vulnerabilityTypeId }
        });
        if (!checkVulnerabilityType)
            return res.status(404).send({
                ok: false,
                message: `No existe el tipo de vulnerabilidad con id: ${body.vulnerabilityTypeId}`,
            });

        let checkVulnerability = await models.Vulnerability.findOne({
            where: { id: body.vulnerabilityId }
        });
        if (!checkVulnerability)
            return res.status(404).send({
                ok: false,
                message: `No existe la vulnerabilidad con id: ${body.vulnerabilityId}`,
            });

        vulnerabilityReport.set({
            title: body.title,
            description: body.description,
            impact: body.impact,
            vulnerabilityTypeId: body.vulnerabilityTypeId,
            vulnerabilityId: body.vulnerabilityId,
            assetId: body.assetId
        })
        await vulnerabilityReport.save();
        saveLog(req, "update", "VulnerabilityReport", vulnerabilityReport.id, req.user.id);

        const msg = vulnerabilityReport.title ?
            `Se edito ${ vulnerabilityReport.title } con exito` :
            'Actualización de datos exitosa'

        const report = await VulnerabilityReport.findOne({
            where: { id: vulnerabilityReport.id },
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        })

        successMsg(res, 200, msg, report);
    } catch (error) {
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//=================================================
//Actualizar archivo de reporte de vulnerabilidad
//=================================================
async function updateFileVulnerabilityReportById(req, res) {
    try {
        if (!req.files) {
            return res.status(400).json({
                ok: false,
                err: {
                    message: "No hay archivo seleccionado"
                }
            });
        }

        const report = await VulnerabilityReport.findOne({ where: { id: req.params.reportId }, include: [models.Hacker] });
        if (!report)
            return exceptionMsg(res, req.params.reportId, 'reporte de Vulnerabilidad');

        if (req.user.Hacker.id !== report.Hacker.id)
            return unauthhorized(res);

        req.params.type = 'reports';
        req.params.format = 'file';
        const file = await uploadFile(req, res)

        if (report.file !== '')
            deleteFile('reports', report.file);

        report.set({ file })
        await report.save();
        saveLog(req, "update file", "report", report.id, req.user.id);
        const msg = report.title ?
            `Actualización de archivo de reporte ${report.title} exitoso` :
            'Registro exitoso'

        successMsg(res, 200, msg, report);
    } catch (error) {
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//==============================================
//Activar desactivar reporte de vulnerabilidad
//==============================================
async function updateVulnerabilityReportStatusById(req, res) {
    try {
        const id = req.params.id;
        const vulnerabilityReport = await VulnerabilityReport.findOne({
            where: { id },
            include: [{
                    model: models.Hacker,
                    include: [models.User]
                },
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ]
        })

        if (!vulnerabilityReport)
            return exceptionMsg(res, id, 'reporte de Vulnerabilidad');
        if (vulnerabilityReport.status != 0)
            vulnerabilityReport.set({ status: 0 })
        else
            vulnerabilityReport.set({ status: 1 })
        await vulnerabilityReport.save();
        saveLog(req, "update status", "VulnerabilityReport", vulnerabilityReport.id, req.user.id);

        const msg = vulnerabilityReport.name ?
            `se actualizo el estatus de ${vulnerabilityReport.name}` :
            'actualización exitosa'

        successMsg(res, 200, msg, vulnerabilityReport);
    } catch (error) {
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//==========================================
//Aprobar reporte de vulnerabilidad
//==========================================
async function approveVulnerabilityReportById(req, res) {
    let transaction = await db.sequelize.transaction();
    try {
        const id = req.params.id;
        const vulnerabilityReport = await VulnerabilityReport.findOne({
            where: { id },
            include: [{ model: models.VulnerabilityType, require: true }]
        });

        if (!vulnerabilityReport)
            return exceptionMsg(res, id, 'reporte de Vulnerabilidad');

        const hacker = await models.Hacker.findOne({
            where: { id: vulnerabilityReport.hackerId },
            include: [models.User]
        });
        const program = await models.Program.findOne({
            where: { id: vulnerabilityReport.programId }
        });
        const usersBusiness = await models.User.findAll({ where: { businessId: program.businessId } });

        vulnerabilityReport.set({ approved: 1 });
        await vulnerabilityReport.save({ transaction });

        hacker.set({ approved: 1, score: hacker.score + vulnerabilityReport.VulnerabilityType.score });
        await hacker.save({ transaction });

        const rankings = await models.Ranking.findAll();
        let rankingHacker = {};

        for (ranking of rankings) {
            if (hacker.score < ranking.maxValue && hacker.score > ranking.minValue) {
                rankingHacker = ranking;
                hacker.set({ rankingId: rankingHacker.id })
                await hacker.save({ transaction });
                break
            }
        }

        await transaction.commit();

        await saveBusinessNotification(res, message.reportApproved, vulnerabilityReport.title, notificationType.report, vulnerabilityReport.id, program.businessId);
        await saveUserNotification(res, message.reportApproved, vulnerabilityReport.title, notificationType.report, vulnerabilityReport.id, hacker.User.id);

        saveLog(req, "approved", "VulnerabilityReport", vulnerabilityReport.id, req.user.id);

        let context = {
            reportTitle: vulnerabilityReport.title,
            logoVulnhunting: `${process.env.BACKEND_URL}file/logo/logo1.png`,
            logoEmail: `${process.env.BACKEND_URL}file/logo/email.png`,
            urlWeb: `${process.env.CLIENT_CORS_URL}`,
            app: `${process.env.APP_NAME}`,
            message: "Tiene un reporte aprobado."
        }
        sendMail('Reporte aprobado', hacker.User.email, 'reportNotification', context);
        usersBusiness.forEach(user => {
            sendMail('Reporte aprobado', user.email, 'reportNotification', context);
        });

        const msg = vulnerabilityReport.title ?
            `se aprobó el reporte ${vulnerabilityReport.title}` :
            'actualización exitosa'

        successMsg(res, 200, msg, vulnerabilityReport)
    } catch (error) {
        await transaction.rollback();
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//==========================================
//Rechazar reporte de vulnerabilidad
//==========================================
async function rejectVulnerabilityReportById(req, res) {
    let transaction = await db.sequelize.transaction();
    try {
        const id = req.params.id;
        const vulnerabilityReport = await VulnerabilityReport.findOne({
            where: { id },
            include: [{ model: models.VulnerabilityType, require: true }]
        })

        if (!vulnerabilityReport)
            return exceptionMsg(res, id, 'reporte de Vulnerabilidad');

        const hacker = await models.Hacker.findOne({
            where: { id: vulnerabilityReport.hackerId },
            include: [models.User]
        });

        vulnerabilityReport.set({ approved: 2 });
        await vulnerabilityReport.save({ transaction });

        hacker.set({ score: hacker.score - vulnerabilityReport.VulnerabilityType.score });
        await hacker.save({ transaction });

        const rankings = await models.Ranking.findAll();
        let rankingHacker = {};

        for (ranking of rankings) {
            if (hacker.score < ranking.maxValue && hacker.score > ranking.minValue) {
                rankingHacker = ranking;
                hacker.set({ rankingId: rankingHacker.id })
                await hacker.save({ transaction });
                break
            }
        }

        await transaction.commit();

        await saveUserNotification(res, message.reportReject, vulnerabilityReport.title, notificationType.report, vulnerabilityReport.id, hacker.User.id);

        saveLog(req, "reject", "VulnerabilityReport", vulnerabilityReport.id, req.user.id);

        var context = {
            email: hacker.User.email,
            reportTitle: vulnerabilityReport.title,
            logoVulnhunting: `${process.env.BACKEND_URL}file/logo/logo1.png`,
            logoEmail: `${process.env.BACKEND_URL}file/logo/email.png`,
            urlWeb: `${process.env.CLIENT_CORS_URL}`,
            app: `${process.env.APP_NAME}`,
            message: "Tiene un reporte rechazado."
        }
        sendMail('Reporte rechazado', hacker.User.email, 'reportNotification', context);

        const msg = vulnerabilityReport.title ?
            `se rechazó el reporte ${vulnerabilityReport.title}` :
            'actualización exitosa'

        successMsg(res, 200, msg, vulnerabilityReport);
    } catch (error) {
        await transaction.rollback();
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//==========================================
// Agregar comentario a reporte
//==========================================
async function saveComment(req, res) {
    let transaction = await db.sequelize.transaction();
    try {
        const body = req.body;

        let report = await VulnerabilityReport.findOne({
            where: { id: req.params.id },
            include: [models.Program, models.Hacker]
        });
        if (!report)
            return exceptionMsg(res, req.params.id, 'reporte de Vulnerabilidad');
        if (report.status === 0)
            return res.status(409).send({
                ok: false,
                message: `El chat para este reporte se encuentra temporalmente cerrado`,
            });

        if (req.user.roleId === 2 && req.user.id !== report.Hacker.userId)
            return unauthhorized(res);

        if (req.user.businessId != undefined && req.user.businessId != null && req.user.businessId !== report.Program.businessId)
            return unauthhorized(res);

        let newComment = {
            message: body.message || 'Archivo',
            reportId: report.id,
            userId: req.user.id,
            status: 1
        }

        const comment = await models.Comment.create(newComment, { transaction });

        if (req.files) {
            req.params.type = 'comments';
            req.params.format = 'file';
            const file = await uploadFile(req, res)
            comment.set({ file })
            await comment.save({ transaction });
        }

        if (req.user.roleId === 3) {
            await saveAdminNotifications(res, message.comment, report.title, notificationType.comment, report.id);
            await saveUserNotification(res, message.comment, report.title, notificationType.comment, report.id, report.Hacker.userId);
        }

        if (req.user.roleId === 2) {
            await saveAdminNotifications(res, message.comment, report.title, notificationType.comment, report.id);
            if (report.approved === 1)
                await saveBusinessNotification(res, message.comment, report.title, notificationType.comment, report.id, report.Program.businessId);
        }

        if (req.user.roleId === 1) {
            await saveUserNotification(res, message.comment, report.title, notificationType.comment, report.id, report.Hacker.userId);

            const user = await models.User.findOne({ where: { id: report.Hacker.userId } });
            let context = {
                reportTitle: report.title,
                logoVulnhunting: `${process.env.BACKEND_URL}file/logo/logo1.png`,
                logoEmail: `${process.env.BACKEND_URL}file/logo/email.png`,
                urlWeb: `${process.env.CLIENT_CORS_URL}`,
                app: `${process.env.APP_NAME}`,
                message: "Tiene un mensaje en el inbox."
            }
            sendMail('Mensaje nuevo en inbox', user.email, 'reportNotification', context);

            if (report.approved === 1) {
                await saveBusinessNotification(res, message.comment, report.title, notificationType.comment, report.id, report.Program.businessId);

                const usersBusiness = await models.User.findAll({ where: { businessId: report.Program.businessId } });
                usersBusiness.forEach(user => {
                    sendMail('Mensaje nuevo en inbox', user.email, 'reportNotification', context);
                });
            }
        }

        await transaction.commit();

        const msg = comment.message ?
            `Mensaje enviado` :
            'Registro exitoso'

        report = await VulnerabilityReport.findOne({
            where: { id: comment.reportId },
            include: [{
                model: models.Comment,
                include: [{
                    model: models.User,
                    include: [models.Hacker, models.Business]
                }],
            }],
            order: [
                [models.Comment, 'id', 'asc']
            ]
        });

        successMsg(res, 200, msg, report);
    } catch (error) {
        await transaction.rollback();
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//==========================================
// Agregar paso a reporte
//==========================================
async function saveStep(req, res) {
    let transaction = await db.sequelize.transaction();
    try {
        const body = req.body;

        let report = await VulnerabilityReport.findOne({ where: { id: req.params.reportId }, include: [models.Hacker] });
        if (!report)
            return exceptionMsg(res, req.params.reportId, 'reporte de Vulnerabilidad');

        if (req.user.Hacker.id !== report.Hacker.id)
            return unauthhorized(res);

        let fileName = ""
        let newStep = {
            reportId: report.id,
            description: body.description,
            stepNumber: Number(body.stepNumber),
            file: fileName,
            status: 1
        }

        let stepNew = await models.Step.create(newStep, { transaction })

        if (req.files && req.files.file != null) {
            req.params.type = 'steps';
            req.params.format = 'file';
            req.params.id = stepNew.id;
            fileName = await uploadFile(req, res);
            stepNew.set({ file: fileName });
            await stepNew.save({ transaction });
        }

        await transaction.commit();
        const msg = stepNew.description ?
            `Paso registrado exitosamente` :
            'Paso registrado exitosamente'

        report = await VulnerabilityReport.findOne({
            where: { id: report.id },
            include: [models.Program,
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        })

        successMsg(res, 200, msg, report);
    } catch (error) {
        await transaction.rollback();
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//==========================================
// Editar paso a reporte
//==========================================
async function editStep(req, res) {
    let transaction = await db.sequelize.transaction();
    try {
        const body = req.body;

        let step = await models.Step.findOne({ where: { id: req.params.stepId }, include: [models.VulnerabilityReport] });
        if (!step)
            return exceptionMsg(res, req.params.stepId, 'paso de reporte de Vulnerabilidad');

        if (req.user.Hacker.id !== step.VulnerabilityReport.hackerId)
            return unauthhorized(res);

        step.set({ description: body.description });

        if (req.files && req.files.file != null) {
            req.params.type = 'steps';
            req.params.format = 'file';
            req.params.id = step.id;
            fileName = await uploadFile(req, res);

            if (step.file !== '')
                deleteFile('steps', step.file);

            step.set({ file: fileName });
        }
        await step.save({ transaction });
        await transaction.commit();
        const msg = step.description ?
            `Paso actualizado exitosamente` :
            'Paso actualizado exitosamente'

        let report = await VulnerabilityReport.findOne({
            where: { id: step.reportId },
            include: [models.Program,
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        })

        successMsg(res, 200, msg, report);
    } catch (error) {
        await transaction.rollback();
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//==========================================
// Eliminar paso a reporte
//==========================================
async function deleteStep(req, res) {
    let transaction = await db.sequelize.transaction();
    try {
        const id = req.params.stepId;

        const step = await models.Step.findOne({ where: { id }, include: [models.VulnerabilityReport] });
        if (!step)
            return exceptionMsg(res, id, 'paso de reporte de Vulnerabilidad');

        if (req.user.Hacker.id !== step.VulnerabilityReport.hackerId)
            return unauthhorized(res);

        const steps = await models.Step.findAll({ where: { reportId: step.reportId } });
        if (steps.length === 1)
            return res.status(400).json({
                ok: false,
                err: {
                    message: "Debe conservar al menos un paso en la explicación"
                }
            });

        await models.Step.destroy({ where: { id } }, { transaction });
        if (step.file !== '')
            deleteFile('steps', step.file);

        await transaction.commit();

        let report = await VulnerabilityReport.findOne({
            where: { id: step.reportId },
            include: [models.Program,
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        })

        successMsg(res, 200, 'Registro eliminado con éxito', report);
    } catch (error) {
        await transaction.rollback();
        errorMsg(res, 500, `lo sentimos hemos cometido un error!`, error);
    }
}

//=====================================================
//Mostrar reporte de vulnerabilidad por id en inbox
//=====================================================
async function getInboxByReportId(req, res) {
    try {
        const id = req.params.id;
        const vulnerabilityReport = await VulnerabilityReport.findOne({
            where: { id },
            include: [{
                    model: models.Program,
                    include: [models.VulnerabilityType]
                },
                models.Hacker,
                models.Vulnerability,
                models.VulnerabilityType,
                models.Asset,
                models.Step,
                {
                    model: models.Comment,
                    include: [{
                        model: models.User,
                        include: [models.Hacker, models.Business]
                    }]
                }
            ],
            order: [
                [models.Step, 'stepNumber', 'asc'],
                [models.Comment, 'id', 'asc']
            ]
        })

        if (!vulnerabilityReport)
            return exceptionMsg(res, id, 'Reporte de Vulnerabilidad');

        if (req.user.roleId === 2 && req.user.id !== vulnerabilityReport.Hacker.userId)
            return unauthhorized(res);

        if (req.user.businessId != undefined && req.user.businessId != null && req.user.businessId !== vulnerabilityReport.Program.businessId)
            return unauthhorized(res);

        successMsg(res, 200, 'correcto', vulnerabilityReport);
    } catch (error) {
        errorMsg(res, 500, 'Ha ocurrido un error', error)
    }
}

module.exports = {
    getVulnerabilityReports,
    getVulnerabilityReportsByStatus,
    getVulnerabilityReportById,
    getVulnerabilityReportsByApproved,
    getVulnerabilityReportsByProgramId,
    getVulnerabilityReportsByHackerId,
    getVulnerabilityReportsByBusinessId,
    getVulnerabilityReportsByVulnerabilityTypeId,
    getVulnerabilityReportsByProgramPublics,
    saveVulnerabilityReport,
    updateFileVulnerabilityReportById,
    updateVulnerabilityReportById,
    updateVulnerabilityReportStatusById,
    approveVulnerabilityReportById,
    rejectVulnerabilityReportById,
    saveComment,
    saveStep,
    editStep,
    deleteStep,
    getInboxByReportId
}